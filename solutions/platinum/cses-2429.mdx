---
id: cses-2429
source: CSES
title: Grid Completion
author: Alexis Tao
---

## Implementation

**Time Complexity:** $\mathcal{O}(N^3)$

<LanguageSection>

<CPPSection>


```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
const int MOD = 1e9 + 7;

/** @return The modular inverse of x */
ll modInverse(ll x, ll MOD) {
	ll res = 1;
	ll b = MOD - 2;
	while (b) {
		if (b & 1) { res = (res * x) % MOD; }
		x = (x * x) % MOD;
		b >>= 1;
	}
	return res;
}

int main() {
	int n;
	cin >> n;

	// Initialize arrays for column position of 'A' and column position of 'B' in each
	// row
	vector<int> colA(n, -1), colB(n, -1), configCount(6, 0);
	vector<bool> hasA(n, false), hasB(n, false);
	vector<ll> fact(n + 1), invFact(n + 1);
	string S;

	// Precompute factorials
	fact[0] = 1;
	for (int i = 1; i <= n; i++) { fact[i] = (fact[i - 1] * i) % MOD; }

	// Compute the modular inverse of the largest factorial first
	invFact[n] = modInverse(fact[n], MOD);

	// Compute modular inverses of all factorials in reverse order
	for (int i = n - 1; i >= 0; i--) { invFact[i] = (invFact[i + 1] * (i + 1)) % MOD; }

	// Read grid and fill arrays colA, colB, hasA, and hasB
	for (int i = 0; i < n; i++) {
		cin >> S;
		for (int j = 0; j < n; j++) {
			if (S[j] == 'A') {
				colA[i] = j;
				hasA[j] = true;
			}
			if (S[j] == 'B') {
				colB[i] = j;
				hasB[j] = true;
			}
		}
	}

	// Count various configurations based on positions of 'A' and 'B'
	for (int i = 0; i < n; i++) {
		if (colA[i] == -1 && colB[i] == -1) { configCount[0]++; }
		if (colA[i] == -1 && colB[i] != -1 && !hasA[colB[i]]) { configCount[1]++; }
		if (colA[i] != -1 && colB[i] == -1 && !hasB[colA[i]]) { configCount[2]++; }
	}

	// Count rows and columns without 'A' or 'B'
	for (int i = 0; i < n; i++) {
		if (!hasA[i] && !hasB[i]) { configCount[3]++; }
		if (!hasA[i]) { configCount[4]++; }
		if (!hasB[i]) { configCount[5]++; }
	}

	/** @return The binomial coefficient C(x, y) modulo MOD */
	auto choose = [&](int x, int y) {
		if (y > x || y < 0) return 0LL;
		return (fact[x] * invFact[y] % MOD) * invFact[x - y] % MOD;
	};

	/** @return The number of valid grid configurations */
	auto f = [&](int i, int j, int k) {
		ll res = (choose(configCount[0], i) * choose(configCount[1], j) % MOD *
		          choose(configCount[2], k) % MOD * choose(configCount[3], i) % MOD);

		// Multiply by the factorials of the number of rows and columns left
		res = (res * fact[i] % MOD * fact[configCount[4] - i - j] % MOD *
		       fact[configCount[5] - i - k] % MOD);

		// Apply inclusion-exclusion principle to adjust the result
		if ((i + j + k) % 2 == 1) { res = (MOD - res); }

		return res;
	};

	// Calculate the number of valid grid configurations
	ll ans = 0;
	for (int i = 0; i <= min(configCount[0], configCount[3]); i++) {
		for (int j = 0; j <= configCount[1]; j++) {
			for (int k = 0; k <= configCount[2]; k++) {
				ans = (ans + f(i, j, k)) % MOD;
			}
		}
	}

	cout << ans << endl;
}
```
</CPPSection>
</LanguageSection>
