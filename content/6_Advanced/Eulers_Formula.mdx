---
id: eulers-formula
title: "Euler's Formula"
author: Benjamin Qi, Alexis Tao
description: A formula for finding the number of faces in a planar graph.
prerequisites:
  - dsu
  - 2DRQ
frequency: 1
---

Euler's Formula, a fundamental gem in mathematics, uncovers a deep connection between the vertices, edges, and faces of 3D shapes. It states that for any polyhedron, the number of vertices minus the number of edges plus the number of faces always equals 2. This seemingly simple equation is used to explore and understand complex shapes with precision and insight.

## Island Archipelago

<FocusProblem problem="island" />

### Explanation

In this problem, Euler's Formula is indirectly relevant through the concept of islands in a grid-based archipelago. Each island can be seen as a region of connected land cells. Euler's Formula, $V−E+F=1$, relates the vertices (land cells), edges (shared boundaries between land cells), and faces (islands) of a planar graph. Initially, with only water, there are no islands (F = 0). As land cells appear and disappear due to changing water levels (modeled by queries), islands form and potentially enclose freshwater lakes. The challenge is to maintain a dynamic count of islands and determine if each island contains a freshwater lake. This involves efficiently managing and updating connected components of land cells and checking for closed loops (cycles) of land cells that surround at least one water cell to identify lakes. The queries ('!' to change water levels and '?' to request current island statistics) dynamically alter the state of the archipelago and prompt recalculations of island counts and freshwater lake checks.

### Implementation

**Steps**
1. Union-Find Class: Manages the connected components (islands). It includes methods for finding the root of a component, unioning two components, and counting the number of components.
2. Grid Representation: The archipelago is represented as an n x n grid, initialized to water (.).
3. Handling Updates (! r c): Changes a cell from water to land or vice versa. If a land cell is added, it connects to neighboring land cells.
4. Handling Queries (?): Returns the total number of islands and the number of islands without lakes. (Detecting lakes needs additional implementation.)

**Time Complexity:  $\mathcal{O}(m * α(n))$**


<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

class UnionFind {
  private:
	vector<int> parent;
	vector<int> rank;
	int components;

  public:
	UnionFind(int n) {
		parent.resize(n);
		rank.resize(n, 0);
		components = 0;
		for (int i = 0; i < n; ++i) { parent[i] = i; }
	}

	int find(int u) {
		if (parent[u] != u) { parent[u] = find(parent[u]); }
		return parent[u];
	}

	void unionSets(int u, int v) {
		int rootU = find(u);
		int rootV = find(v);
		if (rootU != rootV) {
			if (rank[rootU] > rank[rootV]) {
				parent[rootV] = rootU;
			} else if (rank[rootU] < rank[rootV]) {
				parent[rootU] = rootV;
			} else {
				parent[rootV] = rootU;
				rank[rootU]++;
			}
			components--;
		}
	}

	void addComponent(int u) {
		if (parent[u] == u) { components++; }
	}

	int getComponentsCount() const { return components; }
};

int main() {
	int n, m;
	cin >> n >> m;

	vector<vector<char>> grid(n, vector<char>(n, '.'));  // '.' for water
	UnionFind uf(n * n);
	vector<bool> hasLake(n * n, false);

	auto index = [&](int r, int c) { return r * n + c; };

	auto isValid = [&](int r, int c) {
		return r >= 0 && r < n && c >= 0 && c < n;
	};

	char type;
	int r, c;

	for (int i = 0; i < m; ++i) {
		cin >> type;
		if (type == '!') {
			cin >> r >> c;
			r--;
			c--;

			if (grid[r][c] == '#') {
				grid[r][c] = '.';                        // Change land to water
				uf.unionSets(index(r, c), index(r, c));  // Handle disconnecting
			} else {
				grid[r][c] = '#';  // Change water to land
				uf.addComponent(index(r, c));

				// Check adjacent cells
				static const vector<pair<int, int>> directions = {
				    {-1, 0}, {1, 0}, {0, -1}, {0, 1}};
				for (const auto &dir : directions) {
					int nr = r + dir.first;
					int nc = c + dir.second;
					if (isValid(nr, nc) && grid[nr][nc] == '#') {
						uf.unionSets(index(r, c), index(nr, nc));
					}
				}
			}
		} else if (type == '?') {
			int islands = uf.getComponentsCount();
			int noLakeIslands = islands;  // Initialize to total islands

			// Check for lakes (this needs an extra logic, e.g., flood fill)
			// This part needs implementation to correctly detect lakes.

			cout << islands << " " << noLakeIslands << endl;
		}
	}

	return 0;
}
```

</CPPSection>
</LanguageSection>

## Valleys

<Problems problems="valleys" />



## Problems

<Problems problems="general" />
